{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nimport constants, { errorCodes } from '../constants';\nimport transition from '../transition';\n\nvar noop = function noop() {};\n\nexport default function withNavigation(router) {\n  var cancelCurrentTransition = void 0;\n  router.config.forwardMap = {};\n  router.navigate = navigate;\n  router.navigateToDefault = navigateToDefault;\n  router.transitionToState = transitionToState;\n  router.cancel = cancel;\n  router.forward = forward;\n  /**\n   * Cancel the current transition if there is one\n   * @return {Object} The router instance\n   */\n\n  function cancel() {\n    if (cancelCurrentTransition) {\n      cancelCurrentTransition('navigate');\n      cancelCurrentTransition = null;\n    }\n\n    return router;\n  }\n  /**\n   * Forward a route to another route, when calling navigate.\n   * Route parameters for the two routes should match to avoid issues.\n   * @param  {String}   fromRoute      The route name\n   * @param  {String}   toRoute  The route params\n   */\n\n\n  function forward(fromRoute, toRoute) {\n    router.config.forwardMap[fromRoute] = toRoute;\n    return router;\n  }\n  /**\n   * Navigate to a route\n   * @param  {String}   routeName      The route name\n   * @param  {Object}   [routeParams]  The route params\n   * @param  {Object}   [options]      The navigation options (`replace`, `reload`, `skipTransition`, `force`)\n   * @param  {Function} [done]         A done node style callback (err, state)\n   * @return {Function}                A cancel function\n   */\n\n\n  function navigate() {\n    var _ref;\n\n    var name = arguments.length <= 0 ? undefined : arguments[0];\n    var lastArg = (_ref = arguments.length - 1, arguments.length <= _ref ? undefined : arguments[_ref]);\n    var done = typeof lastArg === 'function' ? lastArg : noop;\n    var params = _typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object' ? arguments.length <= 1 ? undefined : arguments[1] : {};\n    var opts = _typeof(arguments.length <= 2 ? undefined : arguments[2]) === 'object' ? arguments.length <= 2 ? undefined : arguments[2] : {};\n\n    if (!router.isStarted()) {\n      done({\n        code: errorCodes.ROUTER_NOT_STARTED\n      });\n      return;\n    }\n\n    var route = router.buildState(name, params);\n\n    if (!route) {\n      var err = {\n        code: errorCodes.ROUTE_NOT_FOUND\n      };\n      done(err);\n      router.invokeEventListeners(constants.TRANSITION_ERROR, null, router.getState(), err);\n      return;\n    }\n\n    var toState = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), {\n      params: route.meta,\n      options: opts\n    });\n    var sameStates = router.getState() ? router.areStatesEqual(router.getState(), toState, false) : false; // Do not proceed further if states are the same and no reload\n    // (no deactivation and no callbacks)\n\n    if (sameStates && !opts.reload && !opts.force) {\n      var _err = {\n        code: errorCodes.SAME_STATES\n      };\n      done(_err);\n      router.invokeEventListeners(constants.TRANSITION_ERROR, toState, router.getState(), _err);\n      return;\n    }\n\n    var fromState = sameStates || opts.reload ? null : router.getState();\n\n    if (opts.skipTransition) {\n      done(null, toState);\n      return noop;\n    } // Transition\n\n\n    return transitionToState(toState, fromState, opts, function (err, state) {\n      if (err) {\n        if (err.redirect) {\n          var _err$redirect = err.redirect,\n              _name = _err$redirect.name,\n              _params = _err$redirect.params;\n          navigate(_name, _params, _extends({}, opts, {\n            force: true,\n            redirected: true\n          }), done);\n        } else {\n          done(err);\n        }\n      } else {\n        router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, fromState, opts);\n        done(null, state);\n      }\n    });\n  }\n  /**\n   * Navigate to the default route (if defined)\n   * @param  {Object}   [opts] The navigation options\n   * @param  {Function} [done] A done node style callback (err, state)\n   * @return {Function}        A cancel function\n   */\n\n\n  function navigateToDefault() {\n    var opts = _typeof(arguments.length <= 0 ? undefined : arguments[0]) === 'object' ? arguments.length <= 0 ? undefined : arguments[0] : {};\n    var done = arguments.length === 2 ? arguments.length <= 1 ? undefined : arguments[1] : typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function' ? arguments.length <= 0 ? undefined : arguments[0] : noop;\n    var options = router.getOptions();\n\n    if (options.defaultRoute) {\n      return navigate(options.defaultRoute, options.defaultParams, opts, done);\n    }\n\n    return function () {};\n  }\n\n  function transitionToState(toState, fromState) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n    cancel();\n    router.invokeEventListeners(constants.TRANSITION_START, toState, fromState);\n    cancelCurrentTransition = transition(router, toState, fromState, options, function (err, state) {\n      cancelCurrentTransition = null;\n      state = state || toState;\n\n      if (err) {\n        if (err.code === errorCodes.TRANSITION_CANCELLED) {\n          router.invokeEventListeners(constants.TRANSITION_CANCEL, toState, fromState);\n        } else {\n          router.invokeEventListeners(constants.TRANSITION_ERROR, toState, fromState, err);\n        }\n\n        done(err);\n      } else {\n        router.setState(state);\n        done(null, state);\n      }\n    });\n    return cancelCurrentTransition;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}