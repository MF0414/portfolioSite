{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport transitionPath, { nameToIDs } from 'router5-transition-path';\nimport resolve from './resolve';\nimport constants, { errorCodes } from '../constants';\nexport default transition;\n\nfunction transition(router, toState, fromState, opts, callback) {\n  var cancelled = false;\n  var completed = false;\n  var options = router.getOptions();\n\n  var _router$getLifecycleF = router.getLifecycleFunctions(),\n      _router$getLifecycleF2 = _slicedToArray(_router$getLifecycleF, 2),\n      canDeactivateFunctions = _router$getLifecycleF2[0],\n      canActivateFunctions = _router$getLifecycleF2[1];\n\n  var middlewareFunctions = router.getMiddlewareFunctions();\n\n  var isCancelled = function isCancelled() {\n    return cancelled;\n  };\n\n  var cancel = function cancel() {\n    if (!cancelled && !completed) {\n      cancelled = true;\n      callback({\n        code: errorCodes.TRANSITION_CANCELLED\n      }, null);\n    }\n  };\n\n  var done = function done(err, state) {\n    completed = true;\n\n    if (isCancelled()) {\n      return;\n    }\n\n    if (!err && options.autoCleanUp) {\n      var activeSegments = nameToIDs(toState.name);\n      Object.keys(canDeactivateFunctions).forEach(function (name) {\n        if (activeSegments.indexOf(name) === -1) router.clearCanDeactivate(name);\n      });\n    }\n\n    callback(err, state || toState);\n  };\n\n  var makeError = function makeError(base, err) {\n    return _extends({}, base, err instanceof Object ? err : {\n      error: err\n    });\n  };\n\n  var isUnknownRoute = toState.name === constants.UNKNOWN_ROUTE;\n  var asyncBase = {\n    isCancelled: isCancelled,\n    toState: toState,\n    fromState: fromState\n  };\n\n  var _transitionPath = transitionPath(toState, fromState),\n      toDeactivate = _transitionPath.toDeactivate,\n      toActivate = _transitionPath.toActivate;\n\n  var canDeactivate = !fromState || opts.forceDeactivate ? [] : function (toState, fromState, cb) {\n    var canDeactivateFunctionMap = toDeactivate.filter(function (name) {\n      return canDeactivateFunctions[name];\n    }).reduce(function (fnMap, name) {\n      return _extends({}, fnMap, _defineProperty({}, name, canDeactivateFunctions[name]));\n    }, {});\n    resolve(canDeactivateFunctionMap, _extends({}, asyncBase, {\n      errorKey: 'segment'\n    }), function (err) {\n      return cb(err ? makeError({\n        code: errorCodes.CANNOT_DEACTIVATE\n      }, err) : null);\n    });\n  };\n  var canActivate = isUnknownRoute ? [] : function (toState, fromState, cb) {\n    var canActivateFunctionMap = toActivate.filter(function (name) {\n      return canActivateFunctions[name];\n    }).reduce(function (fnMap, name) {\n      return _extends({}, fnMap, _defineProperty({}, name, canActivateFunctions[name]));\n    }, {});\n    resolve(canActivateFunctionMap, _extends({}, asyncBase, {\n      errorKey: 'segment'\n    }), function (err) {\n      return cb(err ? makeError({\n        code: errorCodes.CANNOT_ACTIVATE\n      }, err) : null);\n    });\n  };\n  var middleware = !middlewareFunctions.length ? [] : function (toState, fromState, cb) {\n    return resolve(middlewareFunctions, _extends({}, asyncBase), function (err, state) {\n      return cb(err ? makeError({\n        code: errorCodes.TRANSITION_ERR\n      }, err) : null, state || toState);\n    });\n  };\n  var pipeline = [].concat(canDeactivate).concat(canActivate).concat(middleware);\n  resolve(pipeline, asyncBase, done);\n  return cancel;\n}","map":null,"metadata":{},"sourceType":"module"}