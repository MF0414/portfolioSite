{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport constants from '../constants';\nexport default function withUtils(router) {\n  router.isActive = isActive;\n  router.areStatesEqual = areStatesEqual;\n  router.areStatesDescendants = areStatesDescendants;\n  router.buildPath = buildPath;\n  router.buildState = buildState;\n  router.matchPath = matchPath;\n  router.setRootPath = setRootPath;\n  /**\n   * Check if a route is currently active\n   * @param  {String}  name                     The route name\n   * @param  {Object}  params                   The route params\n   * @param  {Boolean} [strictEquality=false]   Whether to check if the given route is the active route, or part of the active route\n   * @param  {Boolean} [ignoreQueryParams=true] Whether to ignore query parameters\n   * @return {Boolean}                          Whether the given route is active\n   */\n\n  function isActive(name) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var strictEquality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var ignoreQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var activeState = router.getState();\n    if (!activeState) return false;\n\n    if (strictEquality || activeState.name === name) {\n      return areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);\n    }\n\n    return areStatesDescendants(router.makeState(name, params), activeState);\n  }\n  /**\n   * Compare two route state objects\n   * @param  {Object}  state1            The route state\n   * @param  {Object}  state2            The other route state\n   * @param  {Boolean} ignoreQueryParams Whether to ignore query parameters or not\n   * @return {Boolean}                   Whether the two route state are equal or not\n   */\n\n\n  function areStatesEqual(state1, state2) {\n    var ignoreQueryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (state1.name !== state2.name) return false;\n\n    var getUrlParams = function getUrlParams(name) {\n      return router.rootNode.getSegmentsByName(name).map(function (segment) {\n        return segment.parser['urlParams'];\n      }).reduce(function (params, p) {\n        return params.concat(p);\n      }, []);\n    };\n\n    var state1Params = ignoreQueryParams ? getUrlParams(state1.name) : Object.keys(state1.params);\n    var state2Params = ignoreQueryParams ? getUrlParams(state2.name) : Object.keys(state2.params);\n    return state1Params.length === state2Params.length && state1Params.every(function (p) {\n      return state1.params[p] === state2.params[p];\n    });\n  }\n  /**\n   * Check if two states are related\n   * @param  {State} parentState  The parent state\n   * @param  {State} childState   The child state\n   * @return {Boolean}            Whether the two states are descendants or not\n   */\n\n\n  function areStatesDescendants(parentState, childState) {\n    var regex = new RegExp('^' + parentState.name + '\\\\.(.*)$');\n    if (!regex.test(childState.name)) return false; // If child state name extends parent state name, and all parent state params\n    // are in child state params.\n\n    return Object.keys(parentState.params).every(function (p) {\n      return parentState.params[p] === childState.params[p];\n    });\n  }\n  /**\n   * Build a path\n   * @param  {String} route  The route name\n   * @param  {Object} params The route params\n   * @return {String}        The path\n   */\n\n\n  function buildPath(route, params) {\n    if (route === constants.UNKNOWN_ROUTE) {\n      return params.path;\n    }\n\n    var paramsWithDefault = _extends({}, router.config.defaultParams[route], params);\n\n    var _router$getOptions = router.getOptions(),\n        trailingSlashMode = _router$getOptions.trailingSlashMode,\n        queryParamsMode = _router$getOptions.queryParamsMode,\n        queryParams = _router$getOptions.queryParams;\n\n    var encodedParams = router.config.encoders[route] ? router.config.encoders[route](paramsWithDefault) : paramsWithDefault;\n    return router.rootNode.buildPath(route, encodedParams, {\n      trailingSlashMode: trailingSlashMode,\n      queryParamsMode: queryParamsMode,\n      queryParams: queryParams\n    });\n  }\n\n  function forwardState(routeName, routeParams) {\n    var name = router.config.forwardMap[routeName] || routeName;\n\n    var params = _extends({}, router.config.defaultParams[routeName], router.config.defaultParams[name], routeParams);\n\n    return {\n      name: name,\n      params: params\n    };\n  }\n\n  function buildState(routeName, routeParams) {\n    var _forwardState = forwardState(routeName, routeParams),\n        name = _forwardState.name,\n        params = _forwardState.params;\n\n    return router.rootNode.buildState(name, params);\n  }\n  /**\n   * Match a path\n   * @param  {String} path     The path to match\n   * @param  {String} [source] The source (optional, used internally)\n   * @return {Object}          The matched state (null if unmatched)\n   */\n\n\n  function matchPath(path, source) {\n    var options = router.getOptions();\n    var match = router.rootNode.matchPath(path, options);\n\n    if (match) {\n      var name = match.name,\n          params = match.params,\n          meta = match.meta;\n      var decodedParams = router.config.decoders[name] ? router.config.decoders[name](params) : params;\n\n      var _forwardState2 = forwardState(name, decodedParams),\n          routeName = _forwardState2.name,\n          routeParams = _forwardState2.params;\n\n      var builtPath = options.rewritePathOnMatch === false ? path : router.buildPath(routeName, routeParams);\n      return router.makeState(routeName, routeParams, builtPath, {\n        params: meta,\n        source: source\n      });\n    }\n\n    return null;\n  }\n  /**\n   * Set the root node path, use carefully. It can be used to set app-wide allowed query parameters.\n   * @param {String} rootPath The root node path\n   */\n\n\n  function setRootPath(rootPath) {\n    router.rootNode.setPath(rootPath);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}