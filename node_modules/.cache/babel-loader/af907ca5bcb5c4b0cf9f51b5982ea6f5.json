{"ast":null,"code":"function _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport transitionPath from './transitionPath';\nexport default function shouldUpdateNode(nodeName) {\n  return function (toState, fromSate) {\n    var _transitionPath = transitionPath(toState, fromSate),\n        intersection = _transitionPath.intersection,\n        toActivate = _transitionPath.toActivate,\n        toDeactivateReversed = _transitionPath.toDeactivate;\n\n    var toDeactivate = [].concat(_toConsumableArray(toDeactivateReversed)).reverse();\n\n    if (toState.meta.options && toState.meta.options.reload) {\n      return true;\n    }\n\n    if (nodeName === intersection) {\n      return true;\n    }\n\n    if (toActivate.indexOf(nodeName) === -1) {\n      return false;\n    }\n\n    var matching = true;\n\n    for (var i = 0; i < toActivate.length; i += 1) {\n      var activatedSegment = toActivate[i];\n      var sameLevelDeactivatedSegment = toDeactivate[i];\n      matching = activatedSegment === sameLevelDeactivatedSegment;\n\n      if (matching && activatedSegment === nodeName) {\n        return true;\n      }\n\n      if (!matching) {\n        return false;\n      }\n    } // Should never be reached\n\n\n    return false;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}