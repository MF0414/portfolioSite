{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport RouteNode from 'route-node';\nimport withUtils from './core/utils';\nimport withRouterLifecycle from './core/router-lifecycle';\nimport withNavigation from './core/navigation';\nimport withMiddleware from './core/middleware';\nimport withObservable from './core/observable';\nimport withPlugins from './core/plugins';\nimport withRouteLifecycle from './core/route-lifecycle';\nimport withCloning from './core/clone';\nimport constants from './constants';\nvar defaultOptions = {\n  trailingSlashMode: 'default',\n  queryParamsMode: 'default',\n  strictTrailingSlash: false,\n  autoCleanUp: true,\n  allowNotFound: false,\n  strongMatching: true,\n  rewritePathOnMatch: true,\n  caseSensitive: false\n  /**\n   * Create a router\n   * @param  {Array}  [routes]          The routes\n   * @param  {Object} [options={}]      The router options\n   * @param  {Object} [dependencies={}] The router dependencies\n   * @return {Object}                   The router instance\n   */\n\n};\n\nfunction createRouter(routes) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var deps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var routerState = null;\n  var stateId = 0;\n  var callbacks = {};\n  var dependencies = deps;\n\n  var options = _extends({}, defaultOptions);\n\n  Object.keys(opts).forEach(function (opt) {\n    return setOption(opt, opts[opt]);\n  });\n  var router = {\n    config: {\n      decoders: {},\n      encoders: {},\n      defaultParams: {}\n    },\n    rootNode: rootNode,\n    getOptions: getOptions,\n    setOption: setOption,\n    getState: getState,\n    setState: setState,\n    makeState: makeState,\n    makeNotFoundState: makeNotFoundState,\n    setDependency: setDependency,\n    setDependencies: setDependencies,\n    getDependencies: getDependencies,\n    add: add,\n    addNode: addNode,\n    executeFactory: executeFactory,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    invokeEventListeners: invokeEventListeners\n    /**\n     * Invoke all event listeners by event name. Possible event names are listed under constants\n     * (`import { constants } from 'router5'`): `ROUTER_START`, `ROUTER_STOP`, `TRANSITION_START`,\n     * `TRANSITION_CANCEL`, `TRANSITION_SUCCESS`, `TRANSITION_ERROR`.\n     * This method is used internally and should not be invoked directly, but it can be useful for\n     * testing purposes.\n     * @private\n     * @name invokeEventListeners\n     * @param  {String}    eventName The event name\n     */\n\n  };\n\n  function invokeEventListeners(eventName) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    ;\n    (callbacks[eventName] || []).forEach(function (cb) {\n      return cb.apply(undefined, args);\n    });\n  }\n  /**\n   * Removes an event listener\n   * @private\n   * @param  {String}   eventName The event name\n   * @param  {Function} cb        The callback to remove\n   */\n\n\n  function removeEventListener(eventName, cb) {\n    callbacks[eventName] = callbacks[eventName].filter(function (_cb) {\n      return _cb !== cb;\n    });\n  }\n  /**\n   * Add an event listener\n   * @private\n   * @param {String}   eventName The event name\n   * @param {Function} cb        The callback to add\n   */\n\n\n  function addEventListener(eventName, cb) {\n    callbacks[eventName] = (callbacks[eventName] || []).concat(cb);\n    return function () {\n      return removeEventListener(eventName, cb);\n    };\n  }\n\n  withUtils(router);\n  withPlugins(router);\n  withMiddleware(router);\n  withObservable(router);\n  withRouteLifecycle(router);\n  withRouterLifecycle(router);\n  withNavigation(router);\n  withCloning(router, createRouter);\n  var rootNode = routes instanceof RouteNode ? routes : new RouteNode('', '', routes, onRouteAdded);\n  router.rootNode = rootNode;\n  return router;\n\n  function onRouteAdded(route) {\n    if (route.canActivate) router.canActivate(route.name, route.canActivate);\n    if (route.forwardTo) router.forward(route.name, route.forwardTo);\n    if (route.decodeParams) router.config.decoders[route.name] = route.decodeParams;\n    if (route.encodeParams) router.config.encoders[route.name] = route.encodeParams;\n    if (route.defaultParams) router.config.defaultParams[route.name] = route.defaultParams;\n  }\n  /**\n   * Build a state object\n   * @param  {String} name         The state name\n   * @param  {Object} params       The state params\n   * @param  {String} path         The state path\n   * @param  {Object} [meta]       The meta object\n   * @param  {Number} [forceId]    The ID to use in meta (incremented by default)\n   * @return {Object}              The state object\n   */\n\n\n  function makeState(name, params, path, meta, forceId) {\n    var state = {};\n\n    var setProp = function setProp(key, value) {\n      return Object.defineProperty(state, key, {\n        value: value,\n        enumerable: true\n      });\n    };\n\n    setProp('name', name);\n    setProp('params', _extends({}, router.config.defaultParams[name], params));\n    setProp('path', path);\n\n    if (meta) {\n      var finalStateId = void 0;\n\n      if (forceId === undefined) {\n        stateId += 1;\n        finalStateId = stateId;\n      } else {\n        finalStateId = forceId;\n      }\n\n      setProp('meta', _extends({}, meta, {\n        id: finalStateId\n      }));\n    }\n\n    return state;\n  }\n  /**\n   * Build a not found state for a given path\n   * @param  {String} path      The unmatched path\n   * @param  {Object} [options] The navigation options\n   * @return {Object}           The not found state object\n   */\n\n\n  function makeNotFoundState(path, options) {\n    return makeState(constants.UNKNOWN_ROUTE, {\n      path: path\n    }, path, {\n      options: options\n    });\n  }\n  /**\n   * Get the current router state\n   * @return {Object} The current state\n   */\n\n\n  function getState() {\n    return routerState;\n  }\n  /**\n   * Set the current router state\n   * @param {Object} state The state object\n   */\n\n\n  function setState(state) {\n    routerState = state;\n\n    if (state && state.meta && typeof state.meta.id === 'number') {\n      stateId = state.meta.id;\n    }\n  }\n  /**\n   * Get router options\n   * @return {Object} The router options\n   */\n\n\n  function getOptions() {\n    return options;\n  }\n  /**\n   * Set an option\n   * @param  {String} option The option name\n   * @param  {*}      value  The option value\n   * @return {Object}       The router instance\n   */\n\n\n  function setOption(option, value) {\n    options[option] = value;\n    return router;\n  }\n  /**\n   * Set a router dependency\n   * @param  {String} dependencyName The dependency name\n   * @param  {*}      dependency     The dependency\n   * @return {Object}                The router instance\n   */\n\n\n  function setDependency(dependencyName, dependency) {\n    dependencies[dependencyName] = dependency;\n    return router;\n  }\n  /**\n   * Add dependencies\n   * @param { Object} deps A object of dependencies (key-value pairs)\n   * @return {Object}      The router instance\n   */\n\n\n  function setDependencies(deps) {\n    Object.keys(deps).forEach(function (depName) {\n      dependencies[depName] = deps[depName];\n    });\n    return router;\n  }\n  /**\n   * Get dependencies\n   * @return {Object} The dependencies\n   */\n\n\n  function getDependencies() {\n    return dependencies;\n  }\n\n  function getInjectables() {\n    return [router, getDependencies()];\n  }\n\n  function executeFactory(factoryFunction) {\n    return factoryFunction.apply(undefined, _toConsumableArray(getInjectables()));\n  }\n  /**\n   * Add routes\n   * @param  {Array} routes A list of routes to add\n   * @return {Object}       The router instance\n   */\n\n\n  function add(routes) {\n    var finalSort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    rootNode.add(routes, onRouteAdded, !finalSort);\n\n    if (finalSort) {\n      rootNode.sortDescendants();\n    }\n\n    return router;\n  }\n  /**\n   * Add a single route (node)\n   * @param {String} name                   The route name (full name)\n   * @param {String} path                   The route path (from parent)\n   * @param {Function} [canActivateHandler] The canActivate handler for this node\n   */\n\n\n  function addNode(name, path, canActivateHandler) {\n    router.rootNode.addNode(name, path);\n    if (canActivateHandler) router.canActivate(name, canActivateHandler);\n    return router;\n  }\n}\n\nexport default createRouter;","map":null,"metadata":{},"sourceType":"module"}