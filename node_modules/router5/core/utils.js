'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = withUtils;

var _constants = require('../constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function withUtils(router) {
    router.isActive = isActive;
    router.areStatesEqual = areStatesEqual;
    router.areStatesDescendants = areStatesDescendants;
    router.buildPath = buildPath;
    router.buildState = buildState;
    router.matchPath = matchPath;
    router.setRootPath = setRootPath;

    /**
     * Check if a route is currently active
     * @param  {String}  name                     The route name
     * @param  {Object}  params                   The route params
     * @param  {Boolean} [strictEquality=false]   Whether to check if the given route is the active route, or part of the active route
     * @param  {Boolean} [ignoreQueryParams=true] Whether to ignore query parameters
     * @return {Boolean}                          Whether the given route is active
     */
    function isActive(name) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var strictEquality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var ignoreQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        var activeState = router.getState();

        if (!activeState) return false;

        if (strictEquality || activeState.name === name) {
            return areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);
        }

        return areStatesDescendants(router.makeState(name, params), activeState);
    }

    /**
     * Compare two route state objects
     * @param  {Object}  state1            The route state
     * @param  {Object}  state2            The other route state
     * @param  {Boolean} ignoreQueryParams Whether to ignore query parameters or not
     * @return {Boolean}                   Whether the two route state are equal or not
     */
    function areStatesEqual(state1, state2) {
        var ignoreQueryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (state1.name !== state2.name) return false;

        var getUrlParams = function getUrlParams(name) {
            return router.rootNode.getSegmentsByName(name).map(function (segment) {
                return segment.parser['urlParams'];
            }).reduce(function (params, p) {
                return params.concat(p);
            }, []);
        };

        var state1Params = ignoreQueryParams ? getUrlParams(state1.name) : Object.keys(state1.params);
        var state2Params = ignoreQueryParams ? getUrlParams(state2.name) : Object.keys(state2.params);

        return state1Params.length === state2Params.length && state1Params.every(function (p) {
            return state1.params[p] === state2.params[p];
        });
    }

    /**
     * Check if two states are related
     * @param  {State} parentState  The parent state
     * @param  {State} childState   The child state
     * @return {Boolean}            Whether the two states are descendants or not
     */
    function areStatesDescendants(parentState, childState) {
        var regex = new RegExp('^' + parentState.name + '\\.(.*)$');
        if (!regex.test(childState.name)) return false;
        // If child state name extends parent state name, and all parent state params
        // are in child state params.
        return Object.keys(parentState.params).every(function (p) {
            return parentState.params[p] === childState.params[p];
        });
    }

    /**
     * Build a path
     * @param  {String} route  The route name
     * @param  {Object} params The route params
     * @return {String}        The path
     */
    function buildPath(route, params) {
        if (route === _constants2.default.UNKNOWN_ROUTE) {
            return params.path;
        }

        var paramsWithDefault = _extends({}, router.config.defaultParams[route], params);

        var _router$getOptions = router.getOptions(),
            trailingSlashMode = _router$getOptions.trailingSlashMode,
            queryParamsMode = _router$getOptions.queryParamsMode,
            queryParams = _router$getOptions.queryParams;

        var encodedParams = router.config.encoders[route] ? router.config.encoders[route](paramsWithDefault) : paramsWithDefault;

        return router.rootNode.buildPath(route, encodedParams, {
            trailingSlashMode: trailingSlashMode,
            queryParamsMode: queryParamsMode,
            queryParams: queryParams
        });
    }

    function forwardState(routeName, routeParams) {
        var name = router.config.forwardMap[routeName] || routeName;
        var params = _extends({}, router.config.defaultParams[routeName], router.config.defaultParams[name], routeParams);

        return {
            name: name,
            params: params
        };
    }

    function buildState(routeName, routeParams) {
        var _forwardState = forwardState(routeName, routeParams),
            name = _forwardState.name,
            params = _forwardState.params;

        return router.rootNode.buildState(name, params);
    }

    /**
     * Match a path
     * @param  {String} path     The path to match
     * @param  {String} [source] The source (optional, used internally)
     * @return {Object}          The matched state (null if unmatched)
     */
    function matchPath(path, source) {
        var options = router.getOptions();
        var match = router.rootNode.matchPath(path, options);

        if (match) {
            var name = match.name,
                params = match.params,
                meta = match.meta;

            var decodedParams = router.config.decoders[name] ? router.config.decoders[name](params) : params;

            var _forwardState2 = forwardState(name, decodedParams),
                routeName = _forwardState2.name,
                routeParams = _forwardState2.params;

            var builtPath = options.rewritePathOnMatch === false ? path : router.buildPath(routeName, routeParams);

            return router.makeState(routeName, routeParams, builtPath, {
                params: meta,
                source: source
            });
        }

        return null;
    }

    /**
     * Set the root node path, use carefully. It can be used to set app-wide allowed query parameters.
     * @param {String} rootPath The root node path
     */
    function setRootPath(rootPath) {
        router.rootNode.setPath(rootPath);
    }
}