'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = resolve;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function resolve(functions, _ref, callback) {
    var isCancelled = _ref.isCancelled,
        toState = _ref.toState,
        fromState = _ref.fromState,
        errorKey = _ref.errorKey;

    var remainingFunctions = Array.isArray(functions) ? functions : Object.keys(functions);

    var isState = function isState(obj) {
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.name !== undefined && obj.params !== undefined && obj.path !== undefined;
    };
    var hasStateChanged = function hasStateChanged(toState, fromState) {
        return fromState.name !== toState.name || fromState.params !== toState.params || fromState.path !== toState.path;
    };

    var mergeStates = function mergeStates(toState, fromState) {
        return _extends({}, fromState, toState, {
            meta: _extends({}, fromState.meta, toState.meta)
        });
    };

    var processFn = function processFn(stepFn, errBase, state, _done) {
        var done = function done(err, newState) {
            if (err) {
                _done(err);
            } else if (newState && newState !== state && isState(newState)) {
                if (hasStateChanged(newState, state)) {
                    console.error('[router5][transition] Warning: state values (name, params, path) were changed during transition process.');
                }

                _done(null, mergeStates(newState, state));
            } else {
                _done(null, state);
            }
        };
        var res = stepFn.call(null, state, fromState, done);
        if (isCancelled()) {
            done(null);
        } else if (typeof res === 'boolean') {
            done(res ? null : errBase);
        } else if (isState(res)) {
            done(null, res);
        } else if (res && typeof res.then === 'function') {
            res.then(function (resVal) {
                if (resVal instanceof Error) done({ error: resVal }, null);else done(null, resVal);
            }, function (err) {
                if (err instanceof Error) {
                    console.error(err.stack || err);
                    done(_extends({}, errBase, { promiseError: err }), null);
                } else {
                    done((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object' ? _extends({}, errBase, err) : errBase, null);
                }
            });
        }
        // else: wait for done to be called
    };

    var next = function next(err, state) {
        if (isCancelled()) {
            callback();
        } else if (err) {
            callback(err);
        } else {
            if (!remainingFunctions.length) {
                callback(null, state);
            } else {
                var isMapped = typeof remainingFunctions[0] === 'string';
                var errBase = errorKey && isMapped ? _defineProperty({}, errorKey, remainingFunctions[0]) : {};
                var stepFn = isMapped ? functions[remainingFunctions[0]] : remainingFunctions[0];

                remainingFunctions = remainingFunctions.slice(1);

                processFn(stepFn, errBase, state, next);
            }
        }
    };

    next(null, toState);
}