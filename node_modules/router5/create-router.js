'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _routeNode = require('route-node');

var _routeNode2 = _interopRequireDefault(_routeNode);

var _utils = require('./core/utils');

var _utils2 = _interopRequireDefault(_utils);

var _routerLifecycle = require('./core/router-lifecycle');

var _routerLifecycle2 = _interopRequireDefault(_routerLifecycle);

var _navigation = require('./core/navigation');

var _navigation2 = _interopRequireDefault(_navigation);

var _middleware = require('./core/middleware');

var _middleware2 = _interopRequireDefault(_middleware);

var _observable = require('./core/observable');

var _observable2 = _interopRequireDefault(_observable);

var _plugins = require('./core/plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _routeLifecycle = require('./core/route-lifecycle');

var _routeLifecycle2 = _interopRequireDefault(_routeLifecycle);

var _clone = require('./core/clone');

var _clone2 = _interopRequireDefault(_clone);

var _constants = require('./constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var defaultOptions = {
    trailingSlashMode: 'default',
    queryParamsMode: 'default',
    strictTrailingSlash: false,
    autoCleanUp: true,
    allowNotFound: false,
    strongMatching: true,
    rewritePathOnMatch: true,
    caseSensitive: false

    /**
     * Create a router
     * @param  {Array}  [routes]          The routes
     * @param  {Object} [options={}]      The router options
     * @param  {Object} [dependencies={}] The router dependencies
     * @return {Object}                   The router instance
     */
};function createRouter(routes) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var deps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var routerState = null;
    var stateId = 0;
    var callbacks = {};
    var dependencies = deps;
    var options = _extends({}, defaultOptions);

    Object.keys(opts).forEach(function (opt) {
        return setOption(opt, opts[opt]);
    });

    var router = {
        config: {
            decoders: {},
            encoders: {},
            defaultParams: {}
        },
        rootNode: rootNode,
        getOptions: getOptions,
        setOption: setOption,
        getState: getState,
        setState: setState,
        makeState: makeState,
        makeNotFoundState: makeNotFoundState,
        setDependency: setDependency,
        setDependencies: setDependencies,
        getDependencies: getDependencies,
        add: add,
        addNode: addNode,
        executeFactory: executeFactory,
        addEventListener: addEventListener,
        removeEventListener: removeEventListener,
        invokeEventListeners: invokeEventListeners

        /**
         * Invoke all event listeners by event name. Possible event names are listed under constants
         * (`import { constants } from 'router5'`): `ROUTER_START`, `ROUTER_STOP`, `TRANSITION_START`,
         * `TRANSITION_CANCEL`, `TRANSITION_SUCCESS`, `TRANSITION_ERROR`.
         * This method is used internally and should not be invoked directly, but it can be useful for
         * testing purposes.
         * @private
         * @name invokeEventListeners
         * @param  {String}    eventName The event name
         */
    };function invokeEventListeners(eventName) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        ;(callbacks[eventName] || []).forEach(function (cb) {
            return cb.apply(undefined, args);
        });
    }

    /**
     * Removes an event listener
     * @private
     * @param  {String}   eventName The event name
     * @param  {Function} cb        The callback to remove
     */
    function removeEventListener(eventName, cb) {
        callbacks[eventName] = callbacks[eventName].filter(function (_cb) {
            return _cb !== cb;
        });
    }

    /**
     * Add an event listener
     * @private
     * @param {String}   eventName The event name
     * @param {Function} cb        The callback to add
     */
    function addEventListener(eventName, cb) {
        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);

        return function () {
            return removeEventListener(eventName, cb);
        };
    }

    (0, _utils2.default)(router);
    (0, _plugins2.default)(router);
    (0, _middleware2.default)(router);
    (0, _observable2.default)(router);
    (0, _routeLifecycle2.default)(router);
    (0, _routerLifecycle2.default)(router);
    (0, _navigation2.default)(router);
    (0, _clone2.default)(router, createRouter);

    var rootNode = routes instanceof _routeNode2.default ? routes : new _routeNode2.default('', '', routes, onRouteAdded);

    router.rootNode = rootNode;

    return router;

    function onRouteAdded(route) {
        if (route.canActivate) router.canActivate(route.name, route.canActivate);

        if (route.forwardTo) router.forward(route.name, route.forwardTo);

        if (route.decodeParams) router.config.decoders[route.name] = route.decodeParams;

        if (route.encodeParams) router.config.encoders[route.name] = route.encodeParams;

        if (route.defaultParams) router.config.defaultParams[route.name] = route.defaultParams;
    }

    /**
     * Build a state object
     * @param  {String} name         The state name
     * @param  {Object} params       The state params
     * @param  {String} path         The state path
     * @param  {Object} [meta]       The meta object
     * @param  {Number} [forceId]    The ID to use in meta (incremented by default)
     * @return {Object}              The state object
     */
    function makeState(name, params, path, meta, forceId) {
        var state = {};
        var setProp = function setProp(key, value) {
            return Object.defineProperty(state, key, { value: value, enumerable: true });
        };
        setProp('name', name);
        setProp('params', _extends({}, router.config.defaultParams[name], params));
        setProp('path', path);

        if (meta) {
            var finalStateId = void 0;

            if (forceId === undefined) {
                stateId += 1;
                finalStateId = stateId;
            } else {
                finalStateId = forceId;
            }

            setProp('meta', _extends({}, meta, { id: finalStateId }));
        }

        return state;
    }

    /**
     * Build a not found state for a given path
     * @param  {String} path      The unmatched path
     * @param  {Object} [options] The navigation options
     * @return {Object}           The not found state object
     */
    function makeNotFoundState(path, options) {
        return makeState(_constants2.default.UNKNOWN_ROUTE, { path: path }, path, { options: options });
    }

    /**
     * Get the current router state
     * @return {Object} The current state
     */
    function getState() {
        return routerState;
    }

    /**
     * Set the current router state
     * @param {Object} state The state object
     */
    function setState(state) {
        routerState = state;

        if (state && state.meta && typeof state.meta.id === 'number') {
            stateId = state.meta.id;
        }
    }

    /**
     * Get router options
     * @return {Object} The router options
     */
    function getOptions() {
        return options;
    }

    /**
     * Set an option
     * @param  {String} option The option name
     * @param  {*}      value  The option value
     * @return {Object}       The router instance
     */
    function setOption(option, value) {
        options[option] = value;
        return router;
    }

    /**
     * Set a router dependency
     * @param  {String} dependencyName The dependency name
     * @param  {*}      dependency     The dependency
     * @return {Object}                The router instance
     */
    function setDependency(dependencyName, dependency) {
        dependencies[dependencyName] = dependency;
        return router;
    }

    /**
     * Add dependencies
     * @param { Object} deps A object of dependencies (key-value pairs)
     * @return {Object}      The router instance
     */
    function setDependencies(deps) {
        Object.keys(deps).forEach(function (depName) {
            dependencies[depName] = deps[depName];
        });

        return router;
    }

    /**
     * Get dependencies
     * @return {Object} The dependencies
     */
    function getDependencies() {
        return dependencies;
    }

    function getInjectables() {
        return [router, getDependencies()];
    }

    function executeFactory(factoryFunction) {
        return factoryFunction.apply(undefined, _toConsumableArray(getInjectables()));
    }

    /**
     * Add routes
     * @param  {Array} routes A list of routes to add
     * @return {Object}       The router instance
     */
    function add(routes) {
        var finalSort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        rootNode.add(routes, onRouteAdded, !finalSort);
        if (finalSort) {
            rootNode.sortDescendants();
        }
        return router;
    }

    /**
     * Add a single route (node)
     * @param {String} name                   The route name (full name)
     * @param {String} path                   The route path (from parent)
     * @param {Function} [canActivateHandler] The canActivate handler for this node
     */
    function addNode(name, path, canActivateHandler) {
        router.rootNode.addNode(name, path);
        if (canActivateHandler) router.canActivate(name, canActivateHandler);
        return router;
    }
}

exports.default = createRouter;